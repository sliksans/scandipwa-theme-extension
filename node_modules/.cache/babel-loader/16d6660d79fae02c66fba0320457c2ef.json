{"ast":null,"code":"/* eslint-disable @scandipwa/scandipwa-guidelines/export-level-one */\n\n/**\n * ScandiPWA - Progressive Web App for Magento\n *\n * Copyright © Scandiweb, Inc. All rights reserved.\n * See LICENSE for license details.\n *\n * @license OSL-3.0 (Open Software License (\"OSL\") v. 3.0)\n * @package scandipwa/base-theme\n * @link https://github.com/scandipwa/base-theme\n */\nimport { clientsClaim } from 'workbox-core';\nimport { ExpirationPlugin } from 'workbox-expiration';\nimport { precacheAndRoute } from 'workbox-precaching';\nimport { registerRoute } from 'workbox-routing';\nimport { StaleWhileRevalidate } from 'workbox-strategies';\nclientsClaim(); // Precache all of the assets generated by your build process.\n// Their URLs are injected into the manifest variable below.\n// This variable must be present somewhere in your service worker file,\n// even if you decide not to use precaching. See https://cra.link/PWA\n\nprecacheAndRoute(self.__WB_MANIFEST); // Cache same-origin image requests\n\nregisterRoute(({\n  url\n}) => url.origin === self.location.origin // cache png, gif, jpeg, jpg in image cache\n&& /.(jpe?g|png|gif)$/.test(url.pathname), new StaleWhileRevalidate({\n  cacheName: 'images',\n  plugins: [// Ensure that once this runtime cache reaches a maximum size the\n  // least-recently used images are removed.\n  new ExpirationPlugin({\n    maxEntries: 50\n  })]\n})); // This allows the web app to trigger skipWaiting via\n// registration.waiting.postMessage({type: 'SKIP_WAITING'})\n\nself.addEventListener('message', event => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\nconst RESPONSE_OK = 200;\n\nconst makeRequestAndUpdateCache = async (request, cache) => {\n  const response = await fetch(request);\n  const isValid = response.status === RESPONSE_OK;\n\n  if (isValid) {\n    cache.put(request.url, response.clone());\n  }\n\n  return response;\n};\n\nconst updateWithFreshDataViaBroadcast = async (request, cache) => {\n  const type = request.headers.get('Application-Model');\n  const revalidatedResponse = await makeRequestAndUpdateCache(request, cache);\n  const responseClone = revalidatedResponse.clone();\n  const broadcast = new BroadcastChannel(type);\n  broadcast.postMessage({\n    payload: await responseClone.json(),\n    type\n  });\n  broadcast.close();\n};\n\nregisterRoute(/\\/graphql/, async ({\n  event\n}) => {\n  const {\n    request\n  } = event;\n  const cache = await caches.open('graphql');\n  const cachedResponse = await cache.match(request);\n\n  if (!cachedResponse) {\n    // If there is no cached response,\n    // we must get the response and save it to cache!\n    return makeRequestAndUpdateCache(request, cache);\n  } // For cached response, still do the request, but in background.\n  // We will use the BroadCast channel to update the client if the data is new\n\n\n  updateWithFreshDataViaBroadcast(request, cache);\n  return cachedResponse;\n}); // respond to document request only in offline\n\nregisterRoute(({\n  request\n}) => {\n  const {\n    url,\n    destination\n  } = request;\n  const {\n    hostname\n  } = new URL(url);\n\n  if (destination !== 'document') {\n    // skip all NON documents\n    return false;\n  }\n\n  if (hostname !== self.location.hostname) {\n    // skip requests to other domains\n    return false;\n  }\n\n  return true;\n}, async ({\n  event\n}) => {\n  const {\n    request\n  } = event;\n  const cache = await caches.open(self.CACHE_NAME);\n  const responseFromCache = await cache.match('/');\n\n  if (!navigator.onLine) {\n    // Always respond from cache if we are offline\n    return responseFromCache;\n  }\n\n  if (!responseFromCache) {\n    // Respond from server\n    const rootResponse = await fetch('/');\n\n    if (rootResponse.status === RESPONSE_OK) {\n      // Cache only 200 responses, to make sure, that when we are\n      // offline the page will still load as normal.\n      cache.put('/', rootResponse.clone());\n    }\n  }\n\n  return fetch(request); // respond from server\n});","map":{"version":3,"sources":["/home/arturs/scandiweb/extension/node_modules/@scandipwa/scandipwa/src/service-worker.js"],"names":["clientsClaim","ExpirationPlugin","precacheAndRoute","registerRoute","StaleWhileRevalidate","self","__WB_MANIFEST","url","origin","location","test","pathname","cacheName","plugins","maxEntries","addEventListener","event","data","type","skipWaiting","RESPONSE_OK","makeRequestAndUpdateCache","request","cache","response","fetch","isValid","status","put","clone","updateWithFreshDataViaBroadcast","headers","get","revalidatedResponse","responseClone","broadcast","BroadcastChannel","postMessage","payload","json","close","caches","open","cachedResponse","match","destination","hostname","URL","CACHE_NAME","responseFromCache","navigator","onLine","rootResponse"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,YAAT,QAA6B,cAA7B;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,oBAAT,QAAqC,oBAArC;AAEAJ,YAAY,G,CAEZ;AACA;AACA;AACA;;AACAE,gBAAgB,CAACG,IAAI,CAACC,aAAN,CAAhB,C,CAEA;;AACAH,aAAa,CACT,CAAC;AAAEI,EAAAA;AAAF,CAAD,KACIA,GAAG,CAACC,MAAJ,KAAeH,IAAI,CAACI,QAAL,CAAcD,MAA7B,CACA;AADA,GAEG,oBAAoBE,IAApB,CAAyBH,GAAG,CAACI,QAA7B,CAJE,EAMT,IAAIP,oBAAJ,CAAyB;AACrBQ,EAAAA,SAAS,EAAE,QADU;AAErBC,EAAAA,OAAO,EAAE,CACL;AACA;AACA,MAAIZ,gBAAJ,CAAqB;AAAEa,IAAAA,UAAU,EAAE;AAAd,GAArB,CAHK;AAFY,CAAzB,CANS,CAAb,C,CAgBA;AACA;;AACAT,IAAI,CAACU,gBAAL,CAAsB,SAAtB,EAAkCC,KAAD,IAAW;AACxC,MAAIA,KAAK,CAACC,IAAN,IAAcD,KAAK,CAACC,IAAN,CAAWC,IAAX,KAAoB,cAAtC,EAAsD;AAClDb,IAAAA,IAAI,CAACc,WAAL;AACH;AACJ,CAJD;AAMA,MAAMC,WAAW,GAAG,GAApB;;AAEA,MAAMC,yBAAyB,GAAG,OAAOC,OAAP,EAAgBC,KAAhB,KAA0B;AACxD,QAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACH,OAAD,CAA5B;AACA,QAAMI,OAAO,GAAGF,QAAQ,CAACG,MAAT,KAAoBP,WAApC;;AAEA,MAAIM,OAAJ,EAAa;AACTH,IAAAA,KAAK,CAACK,GAAN,CAAUN,OAAO,CAACf,GAAlB,EAAuBiB,QAAQ,CAACK,KAAT,EAAvB;AACH;;AAED,SAAOL,QAAP;AACH,CATD;;AAWA,MAAMM,+BAA+B,GAAG,OAAOR,OAAP,EAAgBC,KAAhB,KAA0B;AAC9D,QAAML,IAAI,GAAGI,OAAO,CAACS,OAAR,CAAgBC,GAAhB,CAAoB,mBAApB,CAAb;AACA,QAAMC,mBAAmB,GAAG,MAAMZ,yBAAyB,CAACC,OAAD,EAAUC,KAAV,CAA3D;AACA,QAAMW,aAAa,GAAGD,mBAAmB,CAACJ,KAApB,EAAtB;AACA,QAAMM,SAAS,GAAG,IAAIC,gBAAJ,CAAqBlB,IAArB,CAAlB;AACAiB,EAAAA,SAAS,CAACE,WAAV,CAAsB;AAAEC,IAAAA,OAAO,EAAE,MAAMJ,aAAa,CAACK,IAAd,EAAjB;AAAuCrB,IAAAA;AAAvC,GAAtB;AACAiB,EAAAA,SAAS,CAACK,KAAV;AACH,CAPD;;AASArC,aAAa,CACT,WADS,EAET,OAAO;AAAEa,EAAAA;AAAF,CAAP,KAAqB;AACjB,QAAM;AAAEM,IAAAA;AAAF,MAAcN,KAApB;AACA,QAAMO,KAAK,GAAG,MAAMkB,MAAM,CAACC,IAAP,CAAY,SAAZ,CAApB;AACA,QAAMC,cAAc,GAAG,MAAMpB,KAAK,CAACqB,KAAN,CAAYtB,OAAZ,CAA7B;;AAEA,MAAI,CAACqB,cAAL,EAAqB;AACjB;AACA;AACA,WAAOtB,yBAAyB,CAACC,OAAD,EAAUC,KAAV,CAAhC;AACH,GATgB,CAWjB;AACA;;;AACAO,EAAAA,+BAA+B,CAACR,OAAD,EAAUC,KAAV,CAA/B;AAEA,SAAOoB,cAAP;AACH,CAlBQ,CAAb,C,CAqBA;;AACAxC,aAAa,CACT,CAAC;AAAEmB,EAAAA;AAAF,CAAD,KAAiB;AACb,QAAM;AAAEf,IAAAA,GAAF;AAAOsC,IAAAA;AAAP,MAAuBvB,OAA7B;AACA,QAAM;AAAEwB,IAAAA;AAAF,MAAe,IAAIC,GAAJ,CAAQxC,GAAR,CAArB;;AAEA,MAAIsC,WAAW,KAAK,UAApB,EAAgC;AAC5B;AACA,WAAO,KAAP;AACH;;AAED,MAAIC,QAAQ,KAAKzC,IAAI,CAACI,QAAL,CAAcqC,QAA/B,EAAyC;AACrC;AACA,WAAO,KAAP;AACH;;AAED,SAAO,IAAP;AACH,CAhBQ,EAiBT,OAAO;AAAE9B,EAAAA;AAAF,CAAP,KAAqB;AACjB,QAAM;AAAEM,IAAAA;AAAF,MAAcN,KAApB;AAEA,QAAMO,KAAK,GAAG,MAAMkB,MAAM,CAACC,IAAP,CAAYrC,IAAI,CAAC2C,UAAjB,CAApB;AACA,QAAMC,iBAAiB,GAAG,MAAM1B,KAAK,CAACqB,KAAN,CAAY,GAAZ,CAAhC;;AAEA,MAAI,CAACM,SAAS,CAACC,MAAf,EAAuB;AACnB;AACA,WAAOF,iBAAP;AACH;;AAED,MAAI,CAACA,iBAAL,EAAwB;AACpB;AACA,UAAMG,YAAY,GAAG,MAAM3B,KAAK,CAAC,GAAD,CAAhC;;AAEA,QAAI2B,YAAY,CAACzB,MAAb,KAAwBP,WAA5B,EAAyC;AACrC;AACA;AACAG,MAAAA,KAAK,CAACK,GAAN,CAAU,GAAV,EAAewB,YAAY,CAACvB,KAAb,EAAf;AACH;AACJ;;AAED,SAAOJ,KAAK,CAACH,OAAD,CAAZ,CAtBiB,CAsBM;AAC1B,CAxCQ,CAAb","sourcesContent":["/* eslint-disable @scandipwa/scandipwa-guidelines/export-level-one */\n\n/**\n * ScandiPWA - Progressive Web App for Magento\n *\n * Copyright © Scandiweb, Inc. All rights reserved.\n * See LICENSE for license details.\n *\n * @license OSL-3.0 (Open Software License (\"OSL\") v. 3.0)\n * @package scandipwa/base-theme\n * @link https://github.com/scandipwa/base-theme\n */\n\nimport { clientsClaim } from 'workbox-core';\nimport { ExpirationPlugin } from 'workbox-expiration';\nimport { precacheAndRoute } from 'workbox-precaching';\nimport { registerRoute } from 'workbox-routing';\nimport { StaleWhileRevalidate } from 'workbox-strategies';\n\nclientsClaim();\n\n// Precache all of the assets generated by your build process.\n// Their URLs are injected into the manifest variable below.\n// This variable must be present somewhere in your service worker file,\n// even if you decide not to use precaching. See https://cra.link/PWA\nprecacheAndRoute(self.__WB_MANIFEST);\n\n// Cache same-origin image requests\nregisterRoute(\n    ({ url }) => (\n        url.origin === self.location.origin\n        // cache png, gif, jpeg, jpg in image cache\n        && /.(jpe?g|png|gif)$/.test(url.pathname)\n    ),\n    new StaleWhileRevalidate({\n        cacheName: 'images',\n        plugins: [\n            // Ensure that once this runtime cache reaches a maximum size the\n            // least-recently used images are removed.\n            new ExpirationPlugin({ maxEntries: 50 })\n        ]\n    })\n);\n\n// This allows the web app to trigger skipWaiting via\n// registration.waiting.postMessage({type: 'SKIP_WAITING'})\nself.addEventListener('message', (event) => {\n    if (event.data && event.data.type === 'SKIP_WAITING') {\n        self.skipWaiting();\n    }\n});\n\nconst RESPONSE_OK = 200;\n\nconst makeRequestAndUpdateCache = async (request, cache) => {\n    const response = await fetch(request);\n    const isValid = response.status === RESPONSE_OK;\n\n    if (isValid) {\n        cache.put(request.url, response.clone());\n    }\n\n    return response;\n};\n\nconst updateWithFreshDataViaBroadcast = async (request, cache) => {\n    const type = request.headers.get('Application-Model');\n    const revalidatedResponse = await makeRequestAndUpdateCache(request, cache);\n    const responseClone = revalidatedResponse.clone();\n    const broadcast = new BroadcastChannel(type);\n    broadcast.postMessage({ payload: await responseClone.json(), type });\n    broadcast.close();\n};\n\nregisterRoute(\n    /\\/graphql/,\n    async ({ event }) => {\n        const { request } = event;\n        const cache = await caches.open('graphql');\n        const cachedResponse = await cache.match(request);\n\n        if (!cachedResponse) {\n            // If there is no cached response,\n            // we must get the response and save it to cache!\n            return makeRequestAndUpdateCache(request, cache);\n        }\n\n        // For cached response, still do the request, but in background.\n        // We will use the BroadCast channel to update the client if the data is new\n        updateWithFreshDataViaBroadcast(request, cache);\n\n        return cachedResponse;\n    }\n);\n\n// respond to document request only in offline\nregisterRoute(\n    ({ request }) => {\n        const { url, destination } = request;\n        const { hostname } = new URL(url);\n\n        if (destination !== 'document') {\n            // skip all NON documents\n            return false;\n        }\n\n        if (hostname !== self.location.hostname) {\n            // skip requests to other domains\n            return false;\n        }\n\n        return true;\n    },\n    async ({ event }) => {\n        const { request } = event;\n\n        const cache = await caches.open(self.CACHE_NAME);\n        const responseFromCache = await cache.match('/');\n\n        if (!navigator.onLine) {\n            // Always respond from cache if we are offline\n            return responseFromCache;\n        }\n\n        if (!responseFromCache) {\n            // Respond from server\n            const rootResponse = await fetch('/');\n\n            if (rootResponse.status === RESPONSE_OK) {\n                // Cache only 200 responses, to make sure, that when we are\n                // offline the page will still load as normal.\n                cache.put('/', rootResponse.clone());\n            }\n        }\n\n        return fetch(request); // respond from server\n    }\n);\n"]},"metadata":{},"sourceType":"module"}